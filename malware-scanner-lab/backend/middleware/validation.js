const path = require('path');

const ALLOWED_EXT = ['.pdf', '.doc', '.docx', '.txt', '.zip'];
const ALLOWED_MIME = [
  'application/pdf',
  'text/plain',
  'application/zip',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
];
const MAX_BYTES = 10 * 1024 * 1024; // 10MB

class ValidationService {
  static isAllowedExtension(filename) {
    const ext = path.extname(filename || '').toLowerCase();
    return ALLOWED_EXT.includes(ext);
  }

  static isAllowedMimeType(mimetype) {
    return ALLOWED_MIME.includes(mimetype);
  }

  static isAllowedFile(file) {
    const extOk = this.isAllowedExtension(file.originalname);
    const mimeOk = this.isAllowedMimeType(file.mimetype);
    return extOk && mimeOk;
  }

  static validateFileSize(size) {
    return size <= MAX_BYTES;
  }

  static getFileValidationErrors(file) {
    const errors = [];
    
    if (!this.isAllowedExtension(file.originalname)) {
      errors.push(`Extensión no permitida. Permitidas: ${ALLOWED_EXT.join(', ')}`);
    }
    
    if (!this.isAllowedMimeType(file.mimetype)) {
      errors.push(`Tipo MIME no permitido. Detectado: ${file.mimetype}`);
    }
    
    if (!this.validateFileSize(file.size)) {
      errors.push(`Archivo excede el tamaño máximo de ${MAX_BYTES / (1024 * 1024)}MB`);
    }
    
    return errors;
  }
}

function validateFile(req, res, next) {
  const file = req.file;
  
  if (!file) {
    return res.status(400).json({ 
      error: 'Archivo requerido',
      code: 'FILE_REQUIRED'
    });
  }

  const errors = ValidationService.getFileValidationErrors(file);
  
  if (errors.length > 0) {
    // Eliminar el archivo subido si falló la validación
    const fs = require('fs');
    try {
      if (fs.existsSync(file.path)) {
        fs.unlinkSync(file.path);
      }
    } catch (cleanupError) {
      console.error('[Validation] Failed to cleanup invalid file:', cleanupError);
    }
    
    return res.status(400).json({ 
      error: 'Archivo no válido',
      details: errors,
      code: 'FILE_VALIDATION_FAILED'
    });
  }

  // Agregar información adicional al archivo
  req.file.validatedAt = new Date().toISOString();
  next();
}

function validateScanId(req, res, next) {
  const { scanId } = req.params;
  
  if (!scanId || typeof scanId !== 'string' || scanId.length < 10) {
    return res.status(400).json({ 
      error: 'ID de escaneo inválido',
      code: 'INVALID_SCAN_ID'
    });
  }
  
  next();
}

function validateFileId(req, res, next) {
  const { fileId } = req.params;
  
  if (!fileId || typeof fileId !== 'string' || fileId.length < 10) {
    return res.status(400).json({ 
      error: 'ID de archivo inválido',
      code: 'INVALID_FILE_ID'
    });
  }
  
  next();
}

module.exports = { 
  validateFile, 
  validateScanId,
  validateFileId,
  ValidationService,
  MAX_BYTES, 
  ALLOWED_EXT,
  ALLOWED_MIME
};

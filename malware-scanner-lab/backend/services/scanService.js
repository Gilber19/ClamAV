const { randomUUID } = require('node:crypto');
const { scans } = require('../utils/store');
const { FileService } = require('./fileService');
const { scanPath } = require('./clamav');

class ScanService {
  static async startScan(fileId) {
    const scanId = randomUUID();
    const meta = await FileService.getFile(fileId);
    
    if (!meta) {
      throw new Error('Archivo no encontrado');
    }

    // Inicializar el estado del escaneo
    scans.set(scanId, { 
      status: 'pending', 
      result: null, 
      fileId,
      createdAt: new Date().toISOString()
    });

    // Ejecutar el escaneo en background
    this.performScan(scanId, meta).catch(error => {
      console.error('[ScanService] Background scan error:', error);
      scans.set(scanId, {
        status: 'error',
        result: { message: error.message },
        fileId,
        createdAt: scans.get(scanId)?.createdAt
      });
    });

    return scanId;
  }

  static async performScan(scanId, fileMeta) {
    try {
      console.log('[ScanService] Starting scan:', { scanId, fileId: fileMeta.originalName });
      
      // Actualizar estado a "scanning"
      const currentScan = scans.get(scanId);
      scans.set(scanId, { 
        ...currentScan, 
        status: 'scanning' 
      });

      // Realizar el escaneo
      const scanResult = await scanPath(fileMeta.path);
      
      // Guardar el resultado
      scans.set(scanId, {
        status: 'completed',
        result: {
          status: scanResult.isInfected ? 'infected' : 'clean',
          signature: scanResult.signature || null,
          meta: fileMeta,
          scannedAt: new Date().toISOString()
        },
        fileId: currentScan.fileId,
        createdAt: currentScan.createdAt
      });

      console.log('[ScanService] Scan completed:', {
        scanId,
        infected: scanResult.isInfected,
        signature: scanResult.signature
      });

    } catch (error) {
      console.error('[ScanService] Scan error:', error);
      
      const currentScan = scans.get(scanId);
      scans.set(scanId, {
        ...currentScan,
        status: 'error',
        result: { 
          message: error.message,
          errorAt: new Date().toISOString()
        }
      });
    }
  }

  static async getScanStatus(scanId) {
    return scans.get(scanId);
  }

  static async getScanResult(scanId) {
    return scans.get(scanId);
  }

  static async getAllScans() {
    return Array.from(scans.entries()).map(([id, data]) => ({
      id,
      ...data
    }));
  }

  static async cleanupOldScans(maxAgeMs = 2 * 60 * 60 * 1000) { // 2 horas por defecto
    const now = Date.now();
    const scansToDelete = [];

    for (const [scanId, scanData] of scans.entries()) {
      const createdTime = new Date(scanData.createdAt).getTime();
      if (now - createdTime > maxAgeMs) {
        scansToDelete.push(scanId);
      }
    }

    for (const scanId of scansToDelete) {
      scans.delete(scanId);
      console.log(`[ScanService] Cleaned up old scan: ${scanId}`);
    }

    return scansToDelete.length;
  }
}

module.exports = { ScanService };
